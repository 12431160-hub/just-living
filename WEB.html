<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>線を描く</title>
<style>
body, html {
    height: 100%;
    margin: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: #f0f0f0;
    position: relative;
}
#drawing-area {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
}
#drawCanvas {
    border: none;
    display: block;
}
#resetButton {
    position: absolute;
    right: 20px;
    bottom: 20px;
    padding: 10px 20px;
    font-size: 16px;
    background-color: #ff6347;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}
#resetButton:hover { background-color: #ff4500; }
.gif-image {
    position: absolute;
    opacity: 0;
    transition: opacity 2s;
    pointer-events: none;
}
</style>
</head>
<body>
<div id="drawing-area">
  <canvas id="drawCanvas"></canvas>
  <button id="resetButton">全リセット</button>
</div>

<!-- BGM（自動ループ再生） -->
<audio id="bgm" src="bgm.mp3" autoplay loop></audio>

<script>
const canvas = document.getElementById('drawCanvas');
const ctx = canvas.getContext('2d');
const resetButton = document.getElementById('resetButton');
const drawingArea = document.getElementById('drawing-area');

// BGM制御（モバイル対策で初回タップで再生保証）
const bgm = document.getElementById('bgm');
bgm.volume = 1; // BGMは100%
document.body.addEventListener('click', () => { 
    if (bgm.paused) bgm.play(); 
}, { once: true });

// building効果音（毎回新規で生成）
function playBuildingSound(){
    const sound = new Audio('building.mp3');
    sound.volume = 0.7; // building効果音を70%
    sound.play();
}

// 背景画像
const backgroundImage = new Image();
backgroundImage.src = 'background.PNG';
let bgLoaded = false;
backgroundImage.onload = () => { bgLoaded = true; drawBackground(); };

function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr,dpr);
    drawBackground();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function drawBackground(){
    if(bgLoaded){
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(backgroundImage, 0, 0, window.innerWidth, window.innerHeight);
    }
}

let drawing = false;
let x = 0, y = 0;
const path = [];
const movingGIFs = [];

function getCanvasRelativePosition(e) {
    const rect = canvas.getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
}

canvas.addEventListener('mousedown', startDrawing);
canvas.addEventListener('mousemove', draw);
canvas.addEventListener('mouseup', stopDrawing);
canvas.addEventListener('mouseleave', stopDrawing);

function startDrawing(e){
    drawing=true;
    const pos=getCanvasRelativePosition(e);
    x=pos.x; y=pos.y;
    path.push({x,y});
}

function stopDrawing(){ drawing=false; }

function draw(e){
    if(!drawing) return;
    const pos=getCanvasRelativePosition(e);
    const newX=pos.x, newY=pos.y;

    ctx.strokeStyle="rgba(0,0,0,0)";
    ctx.lineWidth=5;
    ctx.beginPath();
    ctx.moveTo(x,y);
    ctx.lineTo(newX,newY);
    ctx.stroke();

    // building（草）30%
    if(Math.random()<0.3){
        const grassImages=['building.png','building2.png','building3.png'];
        const img=new Image();
        img.src=grassImages[Math.floor(Math.random()*grassImages.length)];
        img.onload=function(){
            const imgWidth=150,imgHeight=200;
            const offsetX=(Math.random()-0.5)*50;
            const offsetY=(Math.random()-0.5)*50;
            ctx.drawImage(img,newX+offsetX-imgWidth/2,newY+offsetY-imgHeight/2,imgWidth,imgHeight);
            playBuildingSound(); // building音を再生
        };
    }

    // GIFは4%
    if(Math.random()<0.04){ placeRandomGIF(newX,newY); }

    path.push({x:newX,y:newY});
    x=newX;y=newY;
}

function placeRandomGIF(x,y){
    const gifImages=['human.GIF','human2.GIF','human3.GIF'];
    const randomImage=gifImages[Math.floor(Math.random()*gifImages.length)];
    const img=document.createElement('img');
    img.src=randomImage;
    img.className='gif-image';

    let size=(randomImage==='human3.GIF')?25:50;
    img.style.width=size+'px';
    img.style.height=size+'px';
    img.style.left=(x+(Math.random()-0.5)*50)+'px';
    img.style.top=(y+(Math.random()-0.5)*50)+'px';

    drawingArea.appendChild(img);
    setTimeout(()=>{img.style.opacity=1;},2000);

    movingGIFs.push({
        element: img,
        x: parseFloat(img.style.left),
        y: parseFloat(img.style.top),
        dx: (Math.random()-0.5)*0.5,
        dy: (Math.random()-0.5)*0.5,
        size: size,
        stopped: false,
        stopTimeout: null
    });

    scheduleStop(movingGIFs[movingGIFs.length-1]);
}

function scheduleStop(gif){
    const nextStop=3000+Math.random()*3000;
    gif.stopTimeout=setTimeout(()=>{
        gif.stopped=true;
        const stopDuration=2000+Math.random()*2000;
        setTimeout(()=>{
            gif.stopped=false;
            scheduleStop(gif);
        },stopDuration);
    },nextStop);
}

function animateGIFs(){
    movingGIFs.forEach(gif=>{
        if(!gif.stopped){
            gif.x+=gif.dx;
            gif.y+=gif.dy;
            if(gif.x<0||gif.x+gif.size>window.innerWidth) gif.dx*=-1;
            if(gif.y<0||gif.y+gif.size>window.innerHeight) gif.dy*=-1;
            gif.element.style.left=gif.x+'px';
            gif.element.style.top=gif.y+'px';
        }
    });
    requestAnimationFrame(animateGIFs);
}
animateGIFs();

resetButton.addEventListener('click',function(){
    path.length=0;
    drawBackground();
    document.querySelectorAll('.gif-image').forEach(el=>el.remove());
    movingGIFs.forEach(gif=>clearTimeout(gif.stopTimeout));
    movingGIFs.length=0;
});
</script>
</body>
</html>